## HashMap的结构
jdk1.7 数组 + 链表  
jdk1.8 数组 + （链表 | 红黑树）

## put流程和扩容
put流程

1. HashMap 是懒惰创建数组的，首次使用才创建数组(不是一上来就创建了容量为16的那个数组,而是在首次调用put方法往里面添加元素的时候才创建数组)
2. 计算索引（桶下标）
3. 如果桶下标还没人占用，创建 Node 占位返回 (如果数组的该下标处没有元素,就把元素放到这个位置)
4. 如果桶下标已经有人占用 (如果该下标位置处已经有元素了,看如果该位置的形成的链表不超过8时,就以尾插法向链表插入该元素.如果链表的元素超过了8个,就向链表形成的红黑树上添加该元素)
   - 已经是 TreeNode 走红黑树的添加或更新逻辑
   - 是普通 Node，走链表的添加或更新逻辑，如果链表长度超过树化阈值，走树化逻辑
5. 返回前检查容量是否超过阈值，一旦超过进行扩容


**1.7 与 1.8 的区别**
- 链表插入节点时，1.7 是头插法，1.8 是尾插法
- 1.7 是大于等于阈值且没有空位时才扩容，而 1.8 是大于阈值就扩容
- 1.8 在扩容计算 Node 索引时，会优化

## 红黑树的形成和退化
- 红黑树用来避免 DoS 攻击，防止链表超长时性能下降，树化应当是偶然情况，是保底策略
- hash 表的查找，更新的时间复杂度是 $O(1)$，而红黑树的查找，更新的时间复杂度是 $O(log_2⁡n )$，TreeNode 占用空间也比普通 Node 的大，如非必要，尽量还是使用链表
- hash 值如果足够随机，则在 hash 表内按泊松分布，在负载因子 0.75 的情况下，长度超过 8 的链表出现概率是 0.00000006，树化阈值选择 8 就是为了让树化几率足够小
  
**树化规则**
当链表长度超过树化阈值 8 时，先尝试扩容来减少链表长度，如果数组容量已经 >=64，才会进行树化

**退化规则**
- 情况1：在扩容时如果拆分树时，树元素个数 <= 6 则会退化链表
- 情况2：remove 树节点时，若 root、root.left、root.right、root.left.left 有一个为 null ，也会退化为链表

## 扩容（加载）因子为何默认是 0.75f
- 如果加载因子太小,数组很容易发生扩容,扩容太频繁会导致占用更多的空间
- 如果加载银子太大,数组很不容易扩容,元素就会形成链表,影响性能
- 所以取0.75F以一个比较好的值

## 索引计算方法
1. 首先，调用对象本身的的 hashCode() (所有类都继承于Object,都会有默认的的hashCode())
2. 再进行调用 HashMap 的 hash() 方法进行二次哈希
   - 二次 hash() 是为了综合高位数据，让哈希分布更为均匀
3. 得到索引(桶下标,根据key计算出来的最终索引,就是要将该key对应的value放到底层数组的哪个下标处),有两种方式计算 
   - 二次哈希值 % capacity 
   - 二次哈希值 & (capacity – 1)得到索引

**小技巧**  
当capacity的值为2的n次幂时,可以使用x & (capacity - 1)的方式来替换x % capacity,如果不是2的n次幂,两种方式算出来的值会有差别  
按位与&运算的性能要高于模运算

## 数组容量为何是 2 的 n 次幂

- 计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模
- 扩容时重新计算索引效率更高： hash & oldCap == 0 的元素留在原来位置 ，否则新位置 = 旧位置 + oldCap

**注意**
- 二次hash是为了配合容量是2的n次幂这一设计前提，如果hash表的容量不是2的n次幂，则不必二次hash
- 容量是2的n次幂这一设计计算索引效率更好，但hash的分散性就不好，需要二次hash来作为补偿，没有采用这一设计的典型例子是Hashtable