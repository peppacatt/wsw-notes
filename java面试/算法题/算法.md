## 二分查找
**什么是二分查找**  
就是一个已排好序的数组的不断的用中间索引的元素去与目标元素比较,直到找到目标元素的索引  

**描述**
1. 前提：有已排序数组 A（假设已经做好）
2. 定义左边界 L、右边界 R，确定搜索范围，循环执行二分查找（3、4两步）
3. 获取中间索引 M = Floor((L+R) /2)
4. 中间索引的值  A[M] 与待搜索的值 T 进行比较
   ① A[M] == T 表示找到，返回中间索引
   ② A[M] > T，中间值右侧的其它元素都大于 T，无需比较，中间索引左边去找，M - 1 设置为右边界，重新查找
   ③ A[M] < T，中间值左侧的其它元素都小于 T，无需比较，中间索引右边去找， M + 1 设置为左边界，重新查找
5. 当 L > R 时，表示没有找到，应结束循环

**代码实现**
```java
public static int binarySearch(int[] a, int t) {
    int l = 0, r = a.length - 1, m;
    while (l <= r) {
        m = (l + r) / 2;
        if (a[m] == t) {
            return m;
        } else if (a[m] > t) {
            r = m - 1;
        } else {
            l = m + 1;
        }
    }
    return -1;
}
```

**解决整数溢出问题**  
当 l 和 r 都较大时，`l + r` 有可能超过整数范围，造成运算错误，解决方法有两种：
```java
int m = l + (r - l) / 2;
```
还有一种是：
```java
int m = (l + r) >>> 1;
```

**其他**  
jdk也有二分查找的实现,Arrays.binarySearch

## 冒泡排序
**描述**  
1. 依次比较数组中相邻两个元素大小，若 a[j] > a[j+1]，则交换两个元素，两两都比较一遍称为一轮冒泡，结果是让最大的元素排至最后
2. 重复以上步骤，直到整个数组有序

**初版**
```java
public static void bubble(int[] a) {
    for (int j = 0; j < a.length - 1; j++) {
        // 一轮冒泡  外层是比较的论数
        boolean swapped = false; // 是否发生了交换
        for (int i = 0; i < a.length - 1 - j; i++) {
            //内层是每一轮具体的比较过程
            System.out.println("比较次数" + i);
            if (a[i] > a[i + 1]) {
                Utils.swap(a, i, i + 1);
                swapped = true;
            }
        }
        System.out.println("第" + j + "轮冒泡"
                           + Arrays.toString(a));
        if (!swapped) {
            break;
        }
    }
}
```
- 优化点1：每经过一轮冒泡，内层循环就可以减少一次
- 优化点2：如果某一轮冒泡没有发生交换，则表示所有数据有序，可以结束外层循环

**优化后的**
```java
public static void bubble_v2(int[] a) {
    int n = a.length - 1;
    while (true) {
        int last = 0; // 表示最后一次交换索引位置
        for (int i = 0; i < n; i++) {
            System.out.println("比较次数" + i);
            if (a[i] > a[i + 1]) {
                Utils.swap(a, i, i + 1);
                last = i;
            }
        }
        n = last;
        System.out.println("第轮冒泡"
                           + Arrays.toString(a));
        if (n == 0) {
            break;
        }
    }
}
```
每轮冒泡时，最后一次交换索引可以作为下一轮冒泡的比较次数，如果这个值为零，表示整个数组有序，直接退出外层循环即可

## 选择排序
**描述**  
- 将数组分为两个子集，排序的和未排序的，每一轮从未排序的子集中选出最小的元素，放入排序子集
- 重复以上步骤，直到整个数组有序

```java
public static void selection(int[] a) {
    for (int i = 0; i < a.length - 1; i++) {
        // i 代表每轮选择最小元素要交换到的目标索引
        int s = i; // 代表最小元素的索引
        for (int j = s + 1; j < a.length; j++) {
            if (a[s] > a[j]) { // j 元素比 s 元素还要小, 更新 s
                s = j;
            }
        }
        if (s != i) {
            swap(a, s, i);
        }
        System.out.println(Arrays.toString(a));
    }
}
```

**冒泡排序和选择排序的比较**
- 二者平均时间复杂度都是 $O(n^2)$
- 选择排序一般要快于冒泡，因为其交换次数少
- 但如果集合有序度高，冒泡优于选择
- 冒泡属于稳定排序算法，而选择属于不稳定排序
  - 稳定排序指，按对象中不同字段进行多次排序，不会打乱同值元素的顺序
  - 不稳定排序则反之